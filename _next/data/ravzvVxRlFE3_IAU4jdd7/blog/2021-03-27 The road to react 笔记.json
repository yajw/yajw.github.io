{"pageProps":{"post":{"title":" The road to react 笔记","comments":true,"date":"2020-12-20T00:00:00.000Z","tags":["react","frontend","笔记"],"categories":["实用"],"modifyTime":"2021-03-27 14:49:15 +0800","createTime":"2021-03-27 14:49:15 +0800","logs":[{"status":["A"],"files":["\"2021-03-27 The road to react \\347\\254\\224\\350\\256\\260.md\""],"abbrevHash":"f4f4061","hash":"f4f406175bde5279c552d8bac1c05cf7bb72d58e","subject":"Copy old posts","authorName":"yajw","authorDate":"2021-03-27 14:49:15 +0800"}],"link":"2021-03-27%20The%20road%20to%20react%20%E7%AC%94%E8%AE%B0","id":"e396f6b4-0832-436f-85ae-01a0aa419932","content":"<h1>1. Fundamentals of React</h1>\n<h2>1.1 Hello React</h2>\n<p><strong>SPA</strong>: 相比每次从服务端请求一个完整的html文件，SPA使得一个js和一个html文件就能完成客户端的绝大部分功能。页面的切换通过js就能完成。\n<strong>React</strong>就是一种能够实现SPA应用或者遵循了SPA原则的技术。\n<strong>Component</strong>是React中的一个重要概念，一个Component定义了它的html/css/js即样式和交互，它能够被整个应用中灵活地复用。\n作者认为的<strong>React的优势</strong>：稳定，且拥有强大的生态和社区。</p>\n<h2>1.2 Requirements</h2>\n<p>编辑器: VSCode\n运行环境：node\n包管理：npm</p>\n<p>依赖包的定义：<code>package.json</code>和<code>package-lock.json</code>\n依赖包本地目录：<code>npm_modules/</code></p>\n<p>npm常用命令</p>\n<ul>\n<li><code>npm install -g &#x3C;module></code>: 全局安装</li>\n<li><code>npm install --save-dev</code>： 调试安装，不会写到<code>package.json</code></li>\n<li><code>npm uninstall &#x3C;module></code>：卸载</li>\n<li><code>npm init -y</code>：初始化</li>\n</ul>\n<p>参考：<a href=\"https://www.robinwieruch.de/npm-crash-course\">npm crash course</a></p>\n<h2>1.3 Setting up a React Project</h2>\n<p>npx命令: <code>execute npm package binaries</code>\n<code>create-react-app</code>： 一个创建/初始化react项目骨架的工具\n通过<code>create-react-app</code>所创建的react项目基本结构：</p>\n<ul>\n<li><code>node_modules/</code>: 依赖目录</li>\n<li><code>public/index.html</code>: 默认<code>src/</code>下的js是处理这个文件</li>\n<li><code>package.json</code>和<code>package-lock.json</code>，同上，另外前者定义了<code>start</code>/<code>build</code>/<code>test</code>命令</li>\n<li><code>src/App.js</code>：应用的Components定义</li>\n<li><code>src/App.css</code>：Components样式</li>\n<li><code>src/index.js</code>：应用入口</li>\n</ul>\n<h2>1.4 Meet the React Component</h2>\n<pre><code class=\"language-javascript\">import React from 'react';\n\nconst target = 'React'\n\nfunction App() {\n  return (\n    &#x3C;div>\n      &#x3C;h1>Hello {target}&#x3C;/h1>\n    &#x3C;/div>\n  )\n}\n\nexport default App;\n</code></pre>\n<p>这个component叫做App，同时也是一个普通的js function，所以也叫做function component。\n这个component返回一段类似html的叫做JSX的代码。\n这个component就是一个普通的js function，可以定义变量以及任何符合js语法的逻辑。</p>\n<h2>1.5 React JSX</h2>\n<p>JSX语法：结合html和js</p>\n<ul>\n<li>特殊关键字：<code>htmlfor</code>, <code>className</code>, <code>onClick</code></li>\n<li><code>{}</code>包含的是js表达式</li>\n</ul>\n<h2>1.6 Lists in React</h2>\n<p>js语法中list有<code>map</code>, <code>filter</code>等方法，也可以用在JSX中：</p>\n<pre><code class=\"language-javascript\">const App = () => (\n  &#x3C;div>\n  {items.map(item => (&#x3C;div key={item.objectID}>{item.title}&#x3C;/div>))}\n  &#x3C;/div>\n)\n</code></pre>\n<p><code>key</code>用来标识一个node。</p>\n<p><code>return null</code> 表示不生成任何html。</p>\n<h2>1.7 Meet another React Component</h2>\n<p>一个定义好的component，可以作为JSX的标签来使用。</p>\n<pre><code class=\"language-javascript\">const Item = ({item}) => (\n  &#x3C;div key={item.objectID}>{item.title}&#x3C;/div>\n)\n\nconst App = () => (\n  &#x3C;div>\n  {items.map(item => (&#x3C;Item item={item}/>))}\n  &#x3C;/div>\n)\n</code></pre>\n<p>一个react应用由此会形成一个组件树。</p>\n<h2>1.8 React Component instantiation</h2>\n<p>js中的class:</p>\n<pre><code class=\"language-javascript\">class Item {\n  constructor(title) {\n    this.title = title\n  }\n}\n\nconst item1 = new Item('test')\n</code></pre>\n<p>当使用JSX语法定义一个component的标签时，也就创建了一个component的实例。</p>\n<h2>1.9 React DOM</h2>\n<pre><code class=\"language-javascript\">ReactDOM.render(\n  &#x3C;App />,\n  document.getElementById('root')\n)\n</code></pre>\n<ol>\n<li><code>ReactDOM.render</code>将JSX渲染为真实的的DOM。</li>\n<li><code>root</code>是<code>public/index.html</code>中的id</li>\n</ol>\n<h2>1.10 React Component Definition (Advanced)</h2>\n<p>定义componenet的几个pattern</p>\n<ol>\n<li>functional component 函数的方式定义component</li>\n<li>arrow function</li>\n<li>定义一个类，继承<code>React.Component</code></li>\n</ol>\n<h2>1.11 Handler Function in JSX</h2>\n<pre><code class=\"language-javascript\">const App = () => {\n  const handleChange = event => {\n    console.log(event.target.value)\n  }\n\n  return (\n    &#x3C;div>\n    &#x3C;label htmlFor=\"search\">Search: &#x3C;/label>\n    &#x3C;input id=\"search\" type=\"text\" onChange={handleChange}>\n    &#x3C;/div>\n  )\n}\n</code></pre>\n<p><code>synthetic event</code>合成事件是对浏览器native event的封装，并且改变了某些行为（例如避免submit时刷新页面）。\nJSX中event handler和js的语法十分相似。</p>\n<h2>1.12 React Props</h2>\n<p>props可以用来在父component到子component的传递参数。</p>\n<pre><code class=\"language-javascript\">const App = () => (\n  &#x3C;div>\n     {items.map(item => &#x3C;Item item={item}>)}\n  &#x3C;/div>\n)\n\nconst Item = props => (\n  &#x3C;div>\n     &#x3C;span>{props.item.title}&#x3C;/span>\n  &#x3C;/div>\n) \n</code></pre>\n<h2>1.13 React State</h2>\n<p>React State能够让component变得interactive。</p>\n<p><code>React.useState()</code></p>\n<ul>\n<li>是一个<code>React Hook</code></li>\n<li>返回一个二元素的数组，第一个是<code>current state</code>，第二个是<code>state updater function</code></li>\n<li>当<code>state updater</code>被调用后，component会重新render</li>\n</ul>\n<pre><code class=\"language-javascript\">const App = () => {\n  const [searchTerm, setSearchTerm] = React.useState('');\n  ...\n}\n</code></pre>\n<h2>1.14 Callback Handlers in JSX</h2>\n<p>props是向下传递的。</p>\n<p>怎么才能让子component传递信息给父component呢？</p>\n<ul>\n<li>父component定义一个callback函数，通过props传递给子component</li>\n<li>子component在处理事件时，调用这个callback函数，实现通知</li>\n</ul>\n<h2>1.15 Lifting State in React</h2>\n<p><code>lift state up</code>:</p>\n<ul>\n<li>\n<ol>\n<li>state定义在多个子component都需要访问的component中（state和面向对象中类的属性有明显的不同）</li>\n</ol>\n</li>\n<li>\n<ol start=\"2\">\n<li>子component通过props和callback来显示和更新state</li>\n</ol>\n</li>\n<li>\n<ol start=\"3\">\n<li>state和<code>state updater</code>更像是event和event handler</li>\n</ol>\n</li>\n<li>\n<ol start=\"4\">\n<li>state的\"作用域\"是整个app的生命周期，所以更像是事件</li>\n</ol>\n</li>\n</ul>\n<h2>1.16 React Controlled Components</h2>\n<p><code>controlled component</code>：把state通过props传递给组件，这时能够拿到state的初始值，同时component变得和普通的html元素几乎一样（除了使用JSX语法表示外）。</p>\n<p><code>component lifecycle</code>：最开始是组件树初始化，同时hooks也用初始值实例化，然后ui就接受各种交互事件，更新state，调用<code>state updater</code>，然后所有相关的component重新render</p>\n<p>特别注意一点：通过各种方式（函数式）定义的component，并不会重新实例化。而Hook也只实例化一次。react内部会去track所有的state。</p>\n<h2>1.17 Props Handling (Advanced)</h2>\n<p>props借助js的descruction语法能够更加简洁。</p>\n<pre><code class=\"language-javascript\">\nconst Item = ({title}) => (\n  &#x3C;div>&#x3C;span>{title}&#x3C;/span>&#x3C;/div>\n)\n\n</code></pre>\n<p>js支持嵌套解耦（nested descructuing）</p>\n<p><code>spread operator</code>: <code>&#x3C;Item {...item} /></code>\n<code>rest operator</code>: <code>const List = ({list}) => list.map(({objectID, ...item}) => &#x3C;Item key={objectID} {...item} />);</code></p>\n<h2>1.18 React Side-Effects</h2>\n<pre><code class=\"language-javascript\">const [searchTerm, setSearchTerm] = React.useState(\n  localStorage.getItem('search') || 'React'\n)\n\nReact.useEffect(() => {\n  localStorage.setItem('search', searchTerm);\n}, [searchTerm])\n\nconst handleSearch = event => {\n  setSearchTerm(event.target.value);\n}\n</code></pre>\n<p>类似注册一个<code>state</code>的\"事件\"处理器。</p>\n<p>和handler区别：</p>\n<ol>\n<li>handler似乎更专注ui</li>\n<li>useEffect更专注处理逻辑（非ui，更接近业务）</li>\n</ol>\n<h2>1.19 React Custom Hooks (Advanced)</h2>\n<p><code>useSemiPersistentState</code>封装了一些特定的逻辑，构成一个custom hook</p>\n<pre><code class=\"language-javascript\">const useSemiPersistentState = (key, initialState) => {\n  const [value, setValue] = React.useState(\n    localStorage.getItem(key) || initialState\n  );\n\n  React.useEffect(() => {\n    localStorage.setItem(key, value);\n  }, [value]);  // 此处应该是笔误，书中是传递[value, key]\n\n  return [value, setValue];\n}\n</code></pre>\n<h2>1.20 React Fragments</h2>\n<p>component返回时如果不想要<code>&#x3C;div></code>包着，需要定义每个元素的key，react支持<code>&#x3C;></code>即所谓fragment，来表示top-level element，但是不会有rendered output。</p>\n<pre><code class=\"language-javascript\">const Search = ({search, onSearch}) = (\n  &#x3C;>\n    &#x3C;label ... />\n    &#x3C;input ... />\n  &#x3C;/>\n)\n</code></pre>\n<h2>1.21 Resuable React Component</h2>\n<p>从search box抽象出<code>InputWithLabel</code>，结合js的<code>default parameter</code>语法，能够让component容易复用。</p>\n<h2>1.22 React Component Composition</h2>\n<p><code>children</code> prop是react的一个特殊的prop，能够支持react component像html element那样嵌套组合：</p>\n<pre><code class=\"language-javascript\">const Input = ({id, children}) => (\n  &#x3C;>\n    &#x3C;input id={id} ... />\n  &#x3C;/>\n)\n\nconst App = () => (\n  &#x3C;div>\n    &#x3C;Input id=\"search\">\n      &#x3C;strong>Search:&#x3C;/strong>\n    &#x3C;/Input>\n  &#x3C;/div>\n)\n</code></pre>\n<h2>1.23 Imperative React</h2>\n<p><code>imperative</code>和<code>declarative</code></p>\n<p>react也支持直接访问dom element，来做一些事：</p>\n<pre><code class=\"language-javascript\">\nconst Input = (isFocused=false) => {\n  const ref = React.useRef()\n\n  React.useEffect(() => {\n    if (isFocused &#x26;&#x26; ref.current) {\n      ref.current.focus();\n    };\n  }, [isFocused]);\n\n  return (\n    &#x3C;>\n      &#x3C;input ref={ref}/>\n    &#x3C;/>\n  )\n}\n</code></pre>\n<h2>1.24 Inline Handler in JSX</h2>\n<pre><code class=\"language-javascript\">const Item = ({item, onRemoveItem}) => (\n  &#x3C;>\n    &#x3C;button onClick={() => onRemoveItem(item)}>\n  &#x3C;/>\n)\n</code></pre>\n<h2>1.25 React Asynchronous Data</h2>\n<p><code>Promise</code>的使用：<code>.then</code>, <code>.catch</code></p>\n<h2>1.26 React Conditional Rendering</h2>\n<pre><code class=\"language-javascript\">{isLoading ? (&#x3C;p>Loading...&#x3C;/p>):()}\n</code></pre>\n<h2>1.27 React Advanced State</h2>\n<p><code>React.useReducer</code></p>\n<p>类似发布事件：</p>\n<ol>\n<li>定义reducer，根据current state,type,action计算下一个状态</li>\n<li>dispatchFunc: 发布action</li>\n</ol>\n<h2>1.28 React Impossible States</h2>\n<p>使用useReducer hook封装多个相关的状态，减少<code>impossible states</code>发生的概率。<code>impossible state</code>发生表示bug，或者带来错误的用户体验。</p>\n<h2>1.29 Data Fetching with React</h2>\n<p><code>fetch</code> api: <code>fetch(url).then(resp => resp.json()).then...</code></p>\n<h2>1.30 Data Re-Fetching in React</h2>\n<p>useEffect绑定一个state，当state变化时会执行对应逻辑，更新或者发布action</p>\n<h2>1.31 Memorized Handler in React (Advanced)</h2>\n<p><code>React.useCallback</code>: 状态发生变化时，直接调用该callback</p>\n<p>死循环？没太看懂</p>\n<h2>1.32 Explicit Data Fetching with React</h2>\n<p>使用\"按钮按下\"的side effect来发api请求，而不是每次input change。</p>\n<p>想清楚ui是如何交互的，何时发生什么事件，然后再设计state。</p>\n<h2>1.33 Third-Party Libraries in React</h2>\n<p><code>fetch</code>是浏览器的api，<code>axios</code>是一个library，用来发异步的请求。</p>\n<pre><code>npm install axios\n\nimport axios from 'axios'\n\naxios.get(url).then(...)\n</code></pre>\n<h2>1.34 Async/Await in React(Advanced)</h2>\n<pre><code class=\"language-javascript\">async () => {\n  const result = await axios.get(url)  // wait\n}\n\n</code></pre>\n<h2>1.35 Forms in React</h2>\n<p><code>event.preventDefault()</code>: prevent browser reload</p>\n<p><code>onSubmit</code>handler: react中处理表单提交的事件</p>\n<h2>总结</h2>\n<ol>\n<li>熟悉JSX语法</li>\n<li>熟悉javascript的一些语法，例如arrow function, destructuring, promise, async/await</li>\n<li>熟悉几个react hooks的用法</li>\n</ol>\n<h1>参考</h1>\n<ul>\n<li>不熟悉前端的必读:https://www.robinwieruch.de/javascript-fundamentals-react-requirements</li>\n</ul>\n"}},"__N_SSG":true}