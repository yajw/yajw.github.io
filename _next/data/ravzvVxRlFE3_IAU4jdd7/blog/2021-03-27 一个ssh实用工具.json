{"pageProps":{"post":{"title":" 一个ssh实用工具","comments":true,"date":"2020-04-06T18:45:40.000Z","tags":["ssh"],"modifyTime":"2021-03-27 14:49:15 +0800","createTime":"2021-03-27 14:49:15 +0800","logs":[{"status":["A"],"files":["\"2021-03-27 \\344\\270\\200\\344\\270\\252ssh\\345\\256\\236\\347\\224\\250\\345\\267\\245\\345\\205\\267.md\""],"abbrevHash":"f4f4061","hash":"f4f406175bde5279c552d8bac1c05cf7bb72d58e","subject":"Copy old posts","authorName":"yajw","authorDate":"2021-03-27 14:49:15 +0800"}],"link":"2021-03-27%20%E4%B8%80%E4%B8%AAssh%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7","id":"592318b9-1392-44db-8018-dcecac4530f8","categories":[],"content":"<h2>需求</h2>\n<p>公司电脑连接很多环境都是通过<code>./ssh/config</code>配置的，并且用到了ssh tunnel。</p>\n<p>每次on duty时，经常需要到日志服务器上抓一些特定的日志。例如拉取一些失败的交易数据，包括请求和响应，给运营去找银行线下处理。</p>\n<p>当然，运营希望看到的是关心的字段都要有，并且最好是excel格式。</p>\n<p>写excel格式还好，关键是有些字段可能要匹配多个不通的日志（例如不同服务的日志匹配），简而言之，需要对日志进行类似join的操作。</p>\n<p>在没有专门用于日志分析的基础设施，并且没有实时性要求的情况下，写个脚本能很有效率地解决这类问题。这时，一个实用的ssh工具就很有用，连接服务器，远程awk几次就ok。</p>\n<p>这本来是一个很小的需求，为什么要单独写一篇博客呢？\n忍不住吐槽下，靠谱的ssh库其实并不多。刚开始想找java的库，试了几个，要么几年没人维护，要么star很多但是解决不了都<code>ssh_config</code>配置和tunnel的问题。</p>\n<p>最后不得已，很不情愿但是没办法，还是回到python，使用paramiko。</p>\n<h2>简单封装</h2>\n<pre><code class=\"language-python\">import os\n\nimport paramiko\n\n\nclass SSHSession(object):\n    def __init__(\n            self,\n            host,\n            port=22,\n            username=None,\n            password=None,\n            key_file_path=None,\n            config_file_path='~/.ssh/config'\n    ):\n        self._host = host\n        self._port = port\n        self._username = username\n        self._password = password\n        self._key_file_path = [key_file_path] if key_file_path else None\n        self._config_file_path = config_file_path\n        self.client = self._connect()\n\n    def exec_command(self, command, timeout=None):\n        stdin, stdout, stderr = self.client.exec_command(command, timeout=timeout)\n        return stdout.readlines(), stderr.readlines()\n\n    def __enter__(self):\n        return self\n\n    def __exit__(self, exc_type, exc_val, exc_tb):\n        if self.client is not None:\n            self.client.close()\n\n    def _connect(self):\n        client = paramiko.SSHClient()\n        client._policy = paramiko.WarningPolicy()\n        client.load_system_host_keys()\n        client.set_missing_host_key_policy(paramiko.AutoAddPolicy())\n\n        ssh_config = paramiko.SSHConfig()\n        user_config_file = os.path.expanduser(self._config_file_path)\n        with open(user_config_file) as f:\n            ssh_config.parse(f)\n\n        user_config = ssh_config.lookup(self._host)\n\n        cfg = {\n            'username': self._username or user_config.get('user', None),\n            'password': self._password,\n            'port': self._port or user_config.get('port', None),\n            'key_filename': self._key_file_path or user_config.get('identityfile', None),\n            'hostname': user_config.get('hostname', None) or self._host,\n            'sock': paramiko.ProxyCommand(user_config['proxycommand']) if 'proxycommand' in user_config else None\n        }\n\n        client.connect(**cfg)\n        return client\n</code></pre>\n<p>交互式shell（作者：<a href=\"https://stackoverflow.com/a/36948840/4886367\">misha</a>）:</p>\n<pre><code class=\"language-python\">import re\n\nfrom ssh.client import SSHSession\n\n\n\nclass ShellHandler:\n\n    def __init__(self, host, **kwargs):\n        self.session = SSHSession(host, **kwargs)\n        self.ssh = self.session.client\n        channel = self.ssh.invoke_shell()\n        self.stdin = channel.makefile('wb')\n        self.stdout = channel.makefile('r')\n\n    def __enter__(self):\n        return self\n\n    def __exit__(self, exc_type, exc_val, exc_tb):\n        if self.ssh is not None:\n            self.ssh.close()\n\n    def execute(self, cmd):\n        \"\"\"\n\n        :param cmd: the command to be executed on the remote computer\n        :examples:  execute('ls')\n                    execute('finger')\n                    execute('cd folder_name')\n        \"\"\"\n        cmd = cmd.strip('\\n')\n        self.stdin.write(cmd + '\\n')\n        finish = 'End-Of-Command-by-ShellHandler'\n        echo_cmd = 'echo {} $?'.format(finish)\n        self.stdin.write(echo_cmd + '\\n')\n        shin = self.stdin\n        self.stdin.flush()\n\n        shout = []\n        sherr = []\n        for line in self.stdout:\n            if str(line).startswith(cmd) or str(line).startswith(echo_cmd):\n                shout = []\n            if str(line).startswith(finish):\n                exit_status = int(str(line).rsplit(None, 1)[1])\n                if exit_status:\n                    sherr = shout\n                    shout = []\n                break\n            else:\n                s = re.compile(r'(\\x9B|\\x1B\\[)[0-?]*[ -/]*[@-~]').sub('', line).replace('\\b', '').replace('\\r', '')\n                if not (finish in s):\n                    shout.append(s)\n\n        if shout and echo_cmd in shout[-1]:\n            shout.pop()\n        if shout and cmd in shout[0]:\n            shout.pop(0)\n        if sherr and echo_cmd in sherr[-1]:\n            sherr.pop()\n        if sherr and cmd in sherr[0]:\n            sherr.pop(0)\n\n        return shin, shout, sherr\n</code></pre>\n<h2>使用</h2>\n<pre><code class=\"language-python\"># SSHSession\nwith SSHSession(\"server0\") as session:\n    print session.exec_command(\"ls\")\n\n# ShellHandler\nwith ShellHandler(\"server2\") as shell:\n    shell.execute(\"cd /home\")\n    shell.execute(\"ls -al\")\n    _, out, err = shell.execute(\"date\")\n    print out\n</code></pre>\n"}},"__N_SSG":true}