{"pageProps":{"post":{"title":" BigTable","comments":true,"date":"2019-09-25T00:05:00.000Z","tags":["Google","BigTable"],"categories":["读书"],"modifyTime":"2021-03-27 14:49:15 +0800","createTime":"2021-03-27 14:49:15 +0800","logs":[{"status":["A"],"files":["2021-03-27 BigTable.md"],"abbrevHash":"f4f4061","hash":"f4f406175bde5279c552d8bac1c05cf7bb72d58e","subject":"Copy old posts","authorName":"yajw","authorDate":"2021-03-27 14:49:15 +0800"}],"link":"2021-03-27%20BigTable","id":"b009d4b0-9fa7-4091-ab69-b0fe3193a18f","content":"<p>这个论文是2006年发表的，当时我还在读高二吧。据论文中所说，BigTable是在03年左右开始的，花了两年多时间，不包含测试的代码在10w行（应该是C++）。</p>\n<p>BigTable是什么？分布式存储系统，设计目标是能够处理大到PT级别的数据量，能够支持数千台服务器的集群。应用场景包括不同数据量（url到网页到卫星图片），吞吐型（批处理），低延迟型（实时查询）。BigTable在处理这些各种各样的场景时，表现出了灵活性和高性能。</p>\n<p>BigTable</p>\n<ol>\n<li>设计思路和特点</li>\n<li>主要优势，怎么实现的</li>\n</ol>\n<ul>\n<li>怎么可靠可伸缩</li>\n<li>高性能</li>\n<li>多场景</li>\n<li>高可用</li>\n<li>一致性</li>\n</ul>\n<ol start=\"3\">\n<li>启发</li>\n</ol>\n<p>BigTabe特点：</p>\n<ul>\n<li>能够可靠地伸缩</li>\n<li>简单的数据模型</li>\n<li>非严格的关系型</li>\n<li>数据结构和格式能够动态变化</li>\n<li>客户端能够对数据底层存储的局部性作出合理推测</li>\n<li>客户端参数能够指定是否从内存而不是硬盘中读</li>\n</ul>\n<h2>数据模型</h2>\n<p>BigTable是稀疏的、分布式、持久化的、多维有序map（原文：A BigTable is a sparse, distributed, persistent multi-dimensional sorted map.）。map的key是row key、column key和timestamp，value是字节数组。</p>\n<pre><code class=\"language-golang\">(row:string, column:string, time:int64) -> string\n</code></pre>\n<p>论文中说采用这种数据模型，是在研究了多种可能的使用场景后确定的。最典型的网页存储，用url作row key、相关信息作column，网页内容放在content这一列下，包含带有时间戳的不同时间采集的各个版本。</p>\n<h3>Rows</h3>\n<p>row key是字符串，最长支持到64kb。</p>\n<p>在同一个row key下，对数据读写操作是原子的。</p>\n<p>BigTable按照row key的字典序maintain data。</p>\n<p>BigTable会按照row key的range来分区，一个range叫做一个table。tablet是负载均衡和分布式的最小单元。</p>\n<h3>Column Families</h3>\n<p>这里为了方便描述，要发明一些（自己的）术语。</p>\n<p>列键标识一列，列族标识一组列键。列族是访问控制的基本单元。</p>\n<p>列族中的数据通常是同一个类型，在BigTable中是压缩存储。</p>\n<p>一个table下，列族最多支持数百个，列键数量则无限制。</p>\n<p>列键的命名格式是：<code>familiy:qualifier</code></p>\n<p>列族的名字必须是printable的，qualifier则可以是任意的。</p>\n<p>访问控制、磁盘和内存审计都在列族层面。</p>\n<h3>timestamp</h3>\n<p>BigTable用时间戳标识数据的多个版本，各个版本按时间戳倒序存储。</p>\n<p>时间戳的格式是64 bit整数，精确到微秒。</p>\n<p>时间戳可以由客户端自己生成。</p>\n<p>BigTable支持两个列族粒度的参数，来用不同策略对比较老的数据版本作垃圾回收：一是保留最近n个版本，二是保留最近某段时间，比如最近7天。</p>\n<h2>API</h2>\n<p>BigTable提供了两种API，一是表和列族的操作，二是管理集群、表、列族的元数据，例如访问权限控制。</p>\n<p>客户端支持，写/删除value，对单行查找value，遍历某个子集。</p>\n<p><code>RowMutation</code>对单行数据作更新。</p>\n<p><code>Scanner</code>支持遍历操作。</p>\n<p>其他的复杂操作：</p>\n<ol>\n<li>单行事务</li>\n<li>允许单个cell作计数器</li>\n<li>支持在服务器上只读脚本（Sawzall语言）</li>\n<li>和MapReduce集成，作为MapReduce的输入输出</li>\n</ol>\n<h2>构件</h2>\n<p>BigTable使用GFS来存储日志和数据文件。</p>\n<p>BigTable运行在Google的共享机器池中，依赖公共的集群管理系统（任务调度、资源分配、故障处理、监控）。</p>\n<p>BigTable内部使用Google的SSTable结构来存储数据。SSTable是持久的、有序的immutable map，key和value都是任意字节串。\nSSTable支持查找、特定key range的遍历。SSTable包含多个blocks，一个block包含64KB。SSTable包含一个block index来快速定位block。block index在SSTable打开时加载到内存中。一次查找只需要一次磁盘seek，首先在内存中找到block，然后读取该block。SSTable也可以配置成完全内存加载方式，避免磁盘操作。</p>\n<h2>BigTable结构</h2>\n<p>逻辑上是多维的有序map，维度包括：row, column family, timestamp。既然是map，维度就是key，value是字符串。其中column family可以有多个（最多数百个），每个column family可以不限数量。</p>\n<p>论文中以一个存储网页数据的表WebTable为例，</p>\n<ul>\n<li>row是倒序的hostname，例如<code>com.yajunw.www</code></li>\n<li>column family有两个\n<ol>\n<li>第一个是<code>content:</code></li>\n<li>第二个是<code>anchor:</code>，它下面有两个column: <code>a.com</code>, <code>b.com</code></li>\n</ol>\n</li>\n<li>timestamp是在横向的，每个value都会有一个timestamp，可以标识数据的版本。</li>\n<li>value是某个时刻的网页文档数据。</li>\n</ul>\n<p>权限控制是到column family这个粒度。</p>\n<p>BigTable没有支持完整的关系型数据模型。\nBigTable只支持行级事务。\nBigTable最多支持2^61(2048PB)的数据量（猜测这个级别可能是不够用的）。</p>\n<p>BigTable提供两个配置：保留最后多少个版本，或者保留最近多少时间的版本。有垃圾回收机制，去做清理和释放空间。</p>\n<p>BigTable解决特定问题而发明的，并不是闭门造车的结果。BigTable不能替代关系型数据库。</p>\n<p>BigTable依赖Chubby，可用性因此也有一定程度依赖Chubby。</p>\n<p>BigTable某些特点似乎是针对网页存储而设计的。</p>\n"}},"__N_SSG":true}