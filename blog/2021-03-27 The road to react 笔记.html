<!DOCTYPE html><html><head><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><title>blog -  The road to react 笔记</title><link rel="icon" href="/favicon.ico"/><link rel="stylesheet" href="/static/css/androidstudio.min.css"/><script src="/static/js/highlight.min.js"></script><script>hljs.highlightAll();</script><meta name="next-head-count" content="7"/><link rel="preload" href="/_next/static/css/3c5946e20da2cc20d075.css" as="style"/><link rel="stylesheet" href="/_next/static/css/3c5946e20da2cc20d075.css" data-n-g=""/><link rel="preload" href="/_next/static/css/e2e6dc732d39303ab748.css" as="style"/><link rel="stylesheet" href="/_next/static/css/e2e6dc732d39303ab748.css" data-n-p=""/><link rel="preload" href="/_next/static/css/4b5ef9ffeb729d4f1c31.css" as="style"/><link rel="stylesheet" href="/_next/static/css/4b5ef9ffeb729d4f1c31.css" data-n-p=""/><noscript data-n-css=""></noscript><link rel="preload" href="/_next/static/chunks/main-c006ee6087559bbd65e3.js" as="script"/><link rel="preload" href="/_next/static/chunks/webpack-50bee04d1dc61f8adf5b.js" as="script"/><link rel="preload" href="/_next/static/chunks/framework.15878d4e523f86636251.js" as="script"/><link rel="preload" href="/_next/static/chunks/99f422a92ff7083adb8a7d840734144fa7589f68.e37cca09058b1656d546.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/_app-86af5e0fcdd51c9c3a66.js" as="script"/><link rel="preload" href="/_next/static/chunks/314642ff.81d3755a1df95fed9f2f.js" as="script"/><link rel="preload" href="/_next/static/chunks/762e22088df2ca7ea97d3f731b2a7315c482f91e.cb9acb13aef2b3683e00.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/blog/%5Blink%5D-87cd50cf458654f0c030.js" as="script"/></head><body><div id="__next"><div class="Home_container__1EcsU"><main class="Home_main__1x8gC"><div class="ui text container"><h1 class="ui header"> The road to react 笔记</h1><span></span><section><h1>1. Fundamentals of React</h1>
<h2>1.1 Hello React</h2>
<p><strong>SPA</strong>: 相比每次从服务端请求一个完整的html文件，SPA使得一个js和一个html文件就能完成客户端的绝大部分功能。页面的切换通过js就能完成。
<strong>React</strong>就是一种能够实现SPA应用或者遵循了SPA原则的技术。
<strong>Component</strong>是React中的一个重要概念，一个Component定义了它的html/css/js即样式和交互，它能够被整个应用中灵活地复用。
作者认为的<strong>React的优势</strong>：稳定，且拥有强大的生态和社区。</p>
<h2>1.2 Requirements</h2>
<p>编辑器: VSCode
运行环境：node
包管理：npm</p>
<p>依赖包的定义：<code>package.json</code>和<code>package-lock.json</code>
依赖包本地目录：<code>npm_modules/</code></p>
<p>npm常用命令</p>
<ul>
<li><code>npm install -g &#x3C;module></code>: 全局安装</li>
<li><code>npm install --save-dev</code>： 调试安装，不会写到<code>package.json</code></li>
<li><code>npm uninstall &#x3C;module></code>：卸载</li>
<li><code>npm init -y</code>：初始化</li>
</ul>
<p>参考：<a href="https://www.robinwieruch.de/npm-crash-course">npm crash course</a></p>
<h2>1.3 Setting up a React Project</h2>
<p>npx命令: <code>execute npm package binaries</code>
<code>create-react-app</code>： 一个创建/初始化react项目骨架的工具
通过<code>create-react-app</code>所创建的react项目基本结构：</p>
<ul>
<li><code>node_modules/</code>: 依赖目录</li>
<li><code>public/index.html</code>: 默认<code>src/</code>下的js是处理这个文件</li>
<li><code>package.json</code>和<code>package-lock.json</code>，同上，另外前者定义了<code>start</code>/<code>build</code>/<code>test</code>命令</li>
<li><code>src/App.js</code>：应用的Components定义</li>
<li><code>src/App.css</code>：Components样式</li>
<li><code>src/index.js</code>：应用入口</li>
</ul>
<h2>1.4 Meet the React Component</h2>
<pre><code class="language-javascript">import React from 'react';

const target = 'React'

function App() {
  return (
    &#x3C;div>
      &#x3C;h1>Hello {target}&#x3C;/h1>
    &#x3C;/div>
  )
}

export default App;
</code></pre>
<p>这个component叫做App，同时也是一个普通的js function，所以也叫做function component。
这个component返回一段类似html的叫做JSX的代码。
这个component就是一个普通的js function，可以定义变量以及任何符合js语法的逻辑。</p>
<h2>1.5 React JSX</h2>
<p>JSX语法：结合html和js</p>
<ul>
<li>特殊关键字：<code>htmlfor</code>, <code>className</code>, <code>onClick</code></li>
<li><code>{}</code>包含的是js表达式</li>
</ul>
<h2>1.6 Lists in React</h2>
<p>js语法中list有<code>map</code>, <code>filter</code>等方法，也可以用在JSX中：</p>
<pre><code class="language-javascript">const App = () => (
  &#x3C;div>
  {items.map(item => (&#x3C;div key={item.objectID}>{item.title}&#x3C;/div>))}
  &#x3C;/div>
)
</code></pre>
<p><code>key</code>用来标识一个node。</p>
<p><code>return null</code> 表示不生成任何html。</p>
<h2>1.7 Meet another React Component</h2>
<p>一个定义好的component，可以作为JSX的标签来使用。</p>
<pre><code class="language-javascript">const Item = ({item}) => (
  &#x3C;div key={item.objectID}>{item.title}&#x3C;/div>
)

const App = () => (
  &#x3C;div>
  {items.map(item => (&#x3C;Item item={item}/>))}
  &#x3C;/div>
)
</code></pre>
<p>一个react应用由此会形成一个组件树。</p>
<h2>1.8 React Component instantiation</h2>
<p>js中的class:</p>
<pre><code class="language-javascript">class Item {
  constructor(title) {
    this.title = title
  }
}

const item1 = new Item('test')
</code></pre>
<p>当使用JSX语法定义一个component的标签时，也就创建了一个component的实例。</p>
<h2>1.9 React DOM</h2>
<pre><code class="language-javascript">ReactDOM.render(
  &#x3C;App />,
  document.getElementById('root')
)
</code></pre>
<ol>
<li><code>ReactDOM.render</code>将JSX渲染为真实的的DOM。</li>
<li><code>root</code>是<code>public/index.html</code>中的id</li>
</ol>
<h2>1.10 React Component Definition (Advanced)</h2>
<p>定义componenet的几个pattern</p>
<ol>
<li>functional component 函数的方式定义component</li>
<li>arrow function</li>
<li>定义一个类，继承<code>React.Component</code></li>
</ol>
<h2>1.11 Handler Function in JSX</h2>
<pre><code class="language-javascript">const App = () => {
  const handleChange = event => {
    console.log(event.target.value)
  }

  return (
    &#x3C;div>
    &#x3C;label htmlFor="search">Search: &#x3C;/label>
    &#x3C;input id="search" type="text" onChange={handleChange}>
    &#x3C;/div>
  )
}
</code></pre>
<p><code>synthetic event</code>合成事件是对浏览器native event的封装，并且改变了某些行为（例如避免submit时刷新页面）。
JSX中event handler和js的语法十分相似。</p>
<h2>1.12 React Props</h2>
<p>props可以用来在父component到子component的传递参数。</p>
<pre><code class="language-javascript">const App = () => (
  &#x3C;div>
     {items.map(item => &#x3C;Item item={item}>)}
  &#x3C;/div>
)

const Item = props => (
  &#x3C;div>
     &#x3C;span>{props.item.title}&#x3C;/span>
  &#x3C;/div>
) 
</code></pre>
<h2>1.13 React State</h2>
<p>React State能够让component变得interactive。</p>
<p><code>React.useState()</code></p>
<ul>
<li>是一个<code>React Hook</code></li>
<li>返回一个二元素的数组，第一个是<code>current state</code>，第二个是<code>state updater function</code></li>
<li>当<code>state updater</code>被调用后，component会重新render</li>
</ul>
<pre><code class="language-javascript">const App = () => {
  const [searchTerm, setSearchTerm] = React.useState('');
  ...
}
</code></pre>
<h2>1.14 Callback Handlers in JSX</h2>
<p>props是向下传递的。</p>
<p>怎么才能让子component传递信息给父component呢？</p>
<ul>
<li>父component定义一个callback函数，通过props传递给子component</li>
<li>子component在处理事件时，调用这个callback函数，实现通知</li>
</ul>
<h2>1.15 Lifting State in React</h2>
<p><code>lift state up</code>:</p>
<ul>
<li>
<ol>
<li>state定义在多个子component都需要访问的component中（state和面向对象中类的属性有明显的不同）</li>
</ol>
</li>
<li>
<ol start="2">
<li>子component通过props和callback来显示和更新state</li>
</ol>
</li>
<li>
<ol start="3">
<li>state和<code>state updater</code>更像是event和event handler</li>
</ol>
</li>
<li>
<ol start="4">
<li>state的"作用域"是整个app的生命周期，所以更像是事件</li>
</ol>
</li>
</ul>
<h2>1.16 React Controlled Components</h2>
<p><code>controlled component</code>：把state通过props传递给组件，这时能够拿到state的初始值，同时component变得和普通的html元素几乎一样（除了使用JSX语法表示外）。</p>
<p><code>component lifecycle</code>：最开始是组件树初始化，同时hooks也用初始值实例化，然后ui就接受各种交互事件，更新state，调用<code>state updater</code>，然后所有相关的component重新render</p>
<p>特别注意一点：通过各种方式（函数式）定义的component，并不会重新实例化。而Hook也只实例化一次。react内部会去track所有的state。</p>
<h2>1.17 Props Handling (Advanced)</h2>
<p>props借助js的descruction语法能够更加简洁。</p>
<pre><code class="language-javascript">
const Item = ({title}) => (
  &#x3C;div>&#x3C;span>{title}&#x3C;/span>&#x3C;/div>
)

</code></pre>
<p>js支持嵌套解耦（nested descructuing）</p>
<p><code>spread operator</code>: <code>&#x3C;Item {...item} /></code>
<code>rest operator</code>: <code>const List = ({list}) => list.map(({objectID, ...item}) => &#x3C;Item key={objectID} {...item} />);</code></p>
<h2>1.18 React Side-Effects</h2>
<pre><code class="language-javascript">const [searchTerm, setSearchTerm] = React.useState(
  localStorage.getItem('search') || 'React'
)

React.useEffect(() => {
  localStorage.setItem('search', searchTerm);
}, [searchTerm])

const handleSearch = event => {
  setSearchTerm(event.target.value);
}
</code></pre>
<p>类似注册一个<code>state</code>的"事件"处理器。</p>
<p>和handler区别：</p>
<ol>
<li>handler似乎更专注ui</li>
<li>useEffect更专注处理逻辑（非ui，更接近业务）</li>
</ol>
<h2>1.19 React Custom Hooks (Advanced)</h2>
<p><code>useSemiPersistentState</code>封装了一些特定的逻辑，构成一个custom hook</p>
<pre><code class="language-javascript">const useSemiPersistentState = (key, initialState) => {
  const [value, setValue] = React.useState(
    localStorage.getItem(key) || initialState
  );

  React.useEffect(() => {
    localStorage.setItem(key, value);
  }, [value]);  // 此处应该是笔误，书中是传递[value, key]

  return [value, setValue];
}
</code></pre>
<h2>1.20 React Fragments</h2>
<p>component返回时如果不想要<code>&#x3C;div></code>包着，需要定义每个元素的key，react支持<code>&#x3C;></code>即所谓fragment，来表示top-level element，但是不会有rendered output。</p>
<pre><code class="language-javascript">const Search = ({search, onSearch}) = (
  &#x3C;>
    &#x3C;label ... />
    &#x3C;input ... />
  &#x3C;/>
)
</code></pre>
<h2>1.21 Resuable React Component</h2>
<p>从search box抽象出<code>InputWithLabel</code>，结合js的<code>default parameter</code>语法，能够让component容易复用。</p>
<h2>1.22 React Component Composition</h2>
<p><code>children</code> prop是react的一个特殊的prop，能够支持react component像html element那样嵌套组合：</p>
<pre><code class="language-javascript">const Input = ({id, children}) => (
  &#x3C;>
    &#x3C;input id={id} ... />
  &#x3C;/>
)

const App = () => (
  &#x3C;div>
    &#x3C;Input id="search">
      &#x3C;strong>Search:&#x3C;/strong>
    &#x3C;/Input>
  &#x3C;/div>
)
</code></pre>
<h2>1.23 Imperative React</h2>
<p><code>imperative</code>和<code>declarative</code></p>
<p>react也支持直接访问dom element，来做一些事：</p>
<pre><code class="language-javascript">
const Input = (isFocused=false) => {
  const ref = React.useRef()

  React.useEffect(() => {
    if (isFocused &#x26;&#x26; ref.current) {
      ref.current.focus();
    };
  }, [isFocused]);

  return (
    &#x3C;>
      &#x3C;input ref={ref}/>
    &#x3C;/>
  )
}
</code></pre>
<h2>1.24 Inline Handler in JSX</h2>
<pre><code class="language-javascript">const Item = ({item, onRemoveItem}) => (
  &#x3C;>
    &#x3C;button onClick={() => onRemoveItem(item)}>
  &#x3C;/>
)
</code></pre>
<h2>1.25 React Asynchronous Data</h2>
<p><code>Promise</code>的使用：<code>.then</code>, <code>.catch</code></p>
<h2>1.26 React Conditional Rendering</h2>
<pre><code class="language-javascript">{isLoading ? (&#x3C;p>Loading...&#x3C;/p>):()}
</code></pre>
<h2>1.27 React Advanced State</h2>
<p><code>React.useReducer</code></p>
<p>类似发布事件：</p>
<ol>
<li>定义reducer，根据current state,type,action计算下一个状态</li>
<li>dispatchFunc: 发布action</li>
</ol>
<h2>1.28 React Impossible States</h2>
<p>使用useReducer hook封装多个相关的状态，减少<code>impossible states</code>发生的概率。<code>impossible state</code>发生表示bug，或者带来错误的用户体验。</p>
<h2>1.29 Data Fetching with React</h2>
<p><code>fetch</code> api: <code>fetch(url).then(resp => resp.json()).then...</code></p>
<h2>1.30 Data Re-Fetching in React</h2>
<p>useEffect绑定一个state，当state变化时会执行对应逻辑，更新或者发布action</p>
<h2>1.31 Memorized Handler in React (Advanced)</h2>
<p><code>React.useCallback</code>: 状态发生变化时，直接调用该callback</p>
<p>死循环？没太看懂</p>
<h2>1.32 Explicit Data Fetching with React</h2>
<p>使用"按钮按下"的side effect来发api请求，而不是每次input change。</p>
<p>想清楚ui是如何交互的，何时发生什么事件，然后再设计state。</p>
<h2>1.33 Third-Party Libraries in React</h2>
<p><code>fetch</code>是浏览器的api，<code>axios</code>是一个library，用来发异步的请求。</p>
<pre><code>npm install axios

import axios from 'axios'

axios.get(url).then(...)
</code></pre>
<h2>1.34 Async/Await in React(Advanced)</h2>
<pre><code class="language-javascript">async () => {
  const result = await axios.get(url)  // wait
}

</code></pre>
<h2>1.35 Forms in React</h2>
<p><code>event.preventDefault()</code>: prevent browser reload</p>
<p><code>onSubmit</code>handler: react中处理表单提交的事件</p>
<h2>总结</h2>
<ol>
<li>熟悉JSX语法</li>
<li>熟悉javascript的一些语法，例如arrow function, destructuring, promise, async/await</li>
<li>熟悉几个react hooks的用法</li>
</ol>
<h1>参考</h1>
<ul>
<li>不熟悉前端的必读:https://www.robinwieruch.de/javascript-fundamentals-react-requirements</li>
</ul>
</section><div role="list" class="ui list"><div role="listitem" class="item">2021-03-27 14:49:15 +0800<!-- --> <!-- -->yajw<!-- --> <!-- -->Copy old posts<!-- --> <!-- -->A</div></div><div id="comments"></div></div></main><footer class="Home_footer__1WdhD"><div class="Home_powered__2GdUA">Powered by<!-- --> <a href="https://nextjs.org/" target="_blank" rel="noopener noreferrer">Next.js</a>.</div></footer></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":" The road to react 笔记","comments":true,"date":"2020-12-20T00:00:00.000Z","tags":["react","frontend","笔记"],"categories":["实用"],"modifyTime":"2021-03-27 14:49:15 +0800","createTime":"2021-03-27 14:49:15 +0800","logs":[{"status":["A"],"files":["\"2021-03-27 The road to react \\347\\254\\224\\350\\256\\260.md\""],"abbrevHash":"f4f4061","hash":"f4f406175bde5279c552d8bac1c05cf7bb72d58e","subject":"Copy old posts","authorName":"yajw","authorDate":"2021-03-27 14:49:15 +0800"}],"link":"2021-03-27%20The%20road%20to%20react%20%E7%AC%94%E8%AE%B0","id":"e396f6b4-0832-436f-85ae-01a0aa419932","content":"\u003ch1\u003e1. Fundamentals of React\u003c/h1\u003e\n\u003ch2\u003e1.1 Hello React\u003c/h2\u003e\n\u003cp\u003e\u003cstrong\u003eSPA\u003c/strong\u003e: 相比每次从服务端请求一个完整的html文件，SPA使得一个js和一个html文件就能完成客户端的绝大部分功能。页面的切换通过js就能完成。\n\u003cstrong\u003eReact\u003c/strong\u003e就是一种能够实现SPA应用或者遵循了SPA原则的技术。\n\u003cstrong\u003eComponent\u003c/strong\u003e是React中的一个重要概念，一个Component定义了它的html/css/js即样式和交互，它能够被整个应用中灵活地复用。\n作者认为的\u003cstrong\u003eReact的优势\u003c/strong\u003e：稳定，且拥有强大的生态和社区。\u003c/p\u003e\n\u003ch2\u003e1.2 Requirements\u003c/h2\u003e\n\u003cp\u003e编辑器: VSCode\n运行环境：node\n包管理：npm\u003c/p\u003e\n\u003cp\u003e依赖包的定义：\u003ccode\u003epackage.json\u003c/code\u003e和\u003ccode\u003epackage-lock.json\u003c/code\u003e\n依赖包本地目录：\u003ccode\u003enpm_modules/\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003enpm常用命令\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003enpm install -g \u0026#x3C;module\u003e\u003c/code\u003e: 全局安装\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003enpm install --save-dev\u003c/code\u003e： 调试安装，不会写到\u003ccode\u003epackage.json\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003enpm uninstall \u0026#x3C;module\u003e\u003c/code\u003e：卸载\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003enpm init -y\u003c/code\u003e：初始化\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e参考：\u003ca href=\"https://www.robinwieruch.de/npm-crash-course\"\u003enpm crash course\u003c/a\u003e\u003c/p\u003e\n\u003ch2\u003e1.3 Setting up a React Project\u003c/h2\u003e\n\u003cp\u003enpx命令: \u003ccode\u003eexecute npm package binaries\u003c/code\u003e\n\u003ccode\u003ecreate-react-app\u003c/code\u003e： 一个创建/初始化react项目骨架的工具\n通过\u003ccode\u003ecreate-react-app\u003c/code\u003e所创建的react项目基本结构：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003enode_modules/\u003c/code\u003e: 依赖目录\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003epublic/index.html\u003c/code\u003e: 默认\u003ccode\u003esrc/\u003c/code\u003e下的js是处理这个文件\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003epackage.json\u003c/code\u003e和\u003ccode\u003epackage-lock.json\u003c/code\u003e，同上，另外前者定义了\u003ccode\u003estart\u003c/code\u003e/\u003ccode\u003ebuild\u003c/code\u003e/\u003ccode\u003etest\u003c/code\u003e命令\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003esrc/App.js\u003c/code\u003e：应用的Components定义\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003esrc/App.css\u003c/code\u003e：Components样式\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003esrc/index.js\u003c/code\u003e：应用入口\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e1.4 Meet the React Component\u003c/h2\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003eimport React from 'react';\n\nconst target = 'React'\n\nfunction App() {\n  return (\n    \u0026#x3C;div\u003e\n      \u0026#x3C;h1\u003eHello {target}\u0026#x3C;/h1\u003e\n    \u0026#x3C;/div\u003e\n  )\n}\n\nexport default App;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e这个component叫做App，同时也是一个普通的js function，所以也叫做function component。\n这个component返回一段类似html的叫做JSX的代码。\n这个component就是一个普通的js function，可以定义变量以及任何符合js语法的逻辑。\u003c/p\u003e\n\u003ch2\u003e1.5 React JSX\u003c/h2\u003e\n\u003cp\u003eJSX语法：结合html和js\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e特殊关键字：\u003ccode\u003ehtmlfor\u003c/code\u003e, \u003ccode\u003eclassName\u003c/code\u003e, \u003ccode\u003eonClick\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e{}\u003c/code\u003e包含的是js表达式\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e1.6 Lists in React\u003c/h2\u003e\n\u003cp\u003ejs语法中list有\u003ccode\u003emap\u003c/code\u003e, \u003ccode\u003efilter\u003c/code\u003e等方法，也可以用在JSX中：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003econst App = () =\u003e (\n  \u0026#x3C;div\u003e\n  {items.map(item =\u003e (\u0026#x3C;div key={item.objectID}\u003e{item.title}\u0026#x3C;/div\u003e))}\n  \u0026#x3C;/div\u003e\n)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003ekey\u003c/code\u003e用来标识一个node。\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003ereturn null\u003c/code\u003e 表示不生成任何html。\u003c/p\u003e\n\u003ch2\u003e1.7 Meet another React Component\u003c/h2\u003e\n\u003cp\u003e一个定义好的component，可以作为JSX的标签来使用。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003econst Item = ({item}) =\u003e (\n  \u0026#x3C;div key={item.objectID}\u003e{item.title}\u0026#x3C;/div\u003e\n)\n\nconst App = () =\u003e (\n  \u0026#x3C;div\u003e\n  {items.map(item =\u003e (\u0026#x3C;Item item={item}/\u003e))}\n  \u0026#x3C;/div\u003e\n)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e一个react应用由此会形成一个组件树。\u003c/p\u003e\n\u003ch2\u003e1.8 React Component instantiation\u003c/h2\u003e\n\u003cp\u003ejs中的class:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003eclass Item {\n  constructor(title) {\n    this.title = title\n  }\n}\n\nconst item1 = new Item('test')\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e当使用JSX语法定义一个component的标签时，也就创建了一个component的实例。\u003c/p\u003e\n\u003ch2\u003e1.9 React DOM\u003c/h2\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003eReactDOM.render(\n  \u0026#x3C;App /\u003e,\n  document.getElementById('root')\n)\n\u003c/code\u003e\u003c/pre\u003e\n\u003col\u003e\n\u003cli\u003e\u003ccode\u003eReactDOM.render\u003c/code\u003e将JSX渲染为真实的的DOM。\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eroot\u003c/code\u003e是\u003ccode\u003epublic/index.html\u003c/code\u003e中的id\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2\u003e1.10 React Component Definition (Advanced)\u003c/h2\u003e\n\u003cp\u003e定义componenet的几个pattern\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003efunctional component 函数的方式定义component\u003c/li\u003e\n\u003cli\u003earrow function\u003c/li\u003e\n\u003cli\u003e定义一个类，继承\u003ccode\u003eReact.Component\u003c/code\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2\u003e1.11 Handler Function in JSX\u003c/h2\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003econst App = () =\u003e {\n  const handleChange = event =\u003e {\n    console.log(event.target.value)\n  }\n\n  return (\n    \u0026#x3C;div\u003e\n    \u0026#x3C;label htmlFor=\"search\"\u003eSearch: \u0026#x3C;/label\u003e\n    \u0026#x3C;input id=\"search\" type=\"text\" onChange={handleChange}\u003e\n    \u0026#x3C;/div\u003e\n  )\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003esynthetic event\u003c/code\u003e合成事件是对浏览器native event的封装，并且改变了某些行为（例如避免submit时刷新页面）。\nJSX中event handler和js的语法十分相似。\u003c/p\u003e\n\u003ch2\u003e1.12 React Props\u003c/h2\u003e\n\u003cp\u003eprops可以用来在父component到子component的传递参数。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003econst App = () =\u003e (\n  \u0026#x3C;div\u003e\n     {items.map(item =\u003e \u0026#x3C;Item item={item}\u003e)}\n  \u0026#x3C;/div\u003e\n)\n\nconst Item = props =\u003e (\n  \u0026#x3C;div\u003e\n     \u0026#x3C;span\u003e{props.item.title}\u0026#x3C;/span\u003e\n  \u0026#x3C;/div\u003e\n) \n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e1.13 React State\u003c/h2\u003e\n\u003cp\u003eReact State能够让component变得interactive。\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eReact.useState()\u003c/code\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e是一个\u003ccode\u003eReact Hook\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e返回一个二元素的数组，第一个是\u003ccode\u003ecurrent state\u003c/code\u003e，第二个是\u003ccode\u003estate updater function\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e当\u003ccode\u003estate updater\u003c/code\u003e被调用后，component会重新render\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003econst App = () =\u003e {\n  const [searchTerm, setSearchTerm] = React.useState('');\n  ...\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e1.14 Callback Handlers in JSX\u003c/h2\u003e\n\u003cp\u003eprops是向下传递的。\u003c/p\u003e\n\u003cp\u003e怎么才能让子component传递信息给父component呢？\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e父component定义一个callback函数，通过props传递给子component\u003c/li\u003e\n\u003cli\u003e子component在处理事件时，调用这个callback函数，实现通知\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e1.15 Lifting State in React\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003elift state up\u003c/code\u003e:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003col\u003e\n\u003cli\u003estate定义在多个子component都需要访问的component中（state和面向对象中类的属性有明显的不同）\u003c/li\u003e\n\u003c/ol\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003col start=\"2\"\u003e\n\u003cli\u003e子component通过props和callback来显示和更新state\u003c/li\u003e\n\u003c/ol\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003col start=\"3\"\u003e\n\u003cli\u003estate和\u003ccode\u003estate updater\u003c/code\u003e更像是event和event handler\u003c/li\u003e\n\u003c/ol\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003col start=\"4\"\u003e\n\u003cli\u003estate的\"作用域\"是整个app的生命周期，所以更像是事件\u003c/li\u003e\n\u003c/ol\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e1.16 React Controlled Components\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003econtrolled component\u003c/code\u003e：把state通过props传递给组件，这时能够拿到state的初始值，同时component变得和普通的html元素几乎一样（除了使用JSX语法表示外）。\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003ecomponent lifecycle\u003c/code\u003e：最开始是组件树初始化，同时hooks也用初始值实例化，然后ui就接受各种交互事件，更新state，调用\u003ccode\u003estate updater\u003c/code\u003e，然后所有相关的component重新render\u003c/p\u003e\n\u003cp\u003e特别注意一点：通过各种方式（函数式）定义的component，并不会重新实例化。而Hook也只实例化一次。react内部会去track所有的state。\u003c/p\u003e\n\u003ch2\u003e1.17 Props Handling (Advanced)\u003c/h2\u003e\n\u003cp\u003eprops借助js的descruction语法能够更加简洁。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003e\nconst Item = ({title}) =\u003e (\n  \u0026#x3C;div\u003e\u0026#x3C;span\u003e{title}\u0026#x3C;/span\u003e\u0026#x3C;/div\u003e\n)\n\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003ejs支持嵌套解耦（nested descructuing）\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003espread operator\u003c/code\u003e: \u003ccode\u003e\u0026#x3C;Item {...item} /\u003e\u003c/code\u003e\n\u003ccode\u003erest operator\u003c/code\u003e: \u003ccode\u003econst List = ({list}) =\u003e list.map(({objectID, ...item}) =\u003e \u0026#x3C;Item key={objectID} {...item} /\u003e);\u003c/code\u003e\u003c/p\u003e\n\u003ch2\u003e1.18 React Side-Effects\u003c/h2\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003econst [searchTerm, setSearchTerm] = React.useState(\n  localStorage.getItem('search') || 'React'\n)\n\nReact.useEffect(() =\u003e {\n  localStorage.setItem('search', searchTerm);\n}, [searchTerm])\n\nconst handleSearch = event =\u003e {\n  setSearchTerm(event.target.value);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e类似注册一个\u003ccode\u003estate\u003c/code\u003e的\"事件\"处理器。\u003c/p\u003e\n\u003cp\u003e和handler区别：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003ehandler似乎更专注ui\u003c/li\u003e\n\u003cli\u003euseEffect更专注处理逻辑（非ui，更接近业务）\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2\u003e1.19 React Custom Hooks (Advanced)\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003euseSemiPersistentState\u003c/code\u003e封装了一些特定的逻辑，构成一个custom hook\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003econst useSemiPersistentState = (key, initialState) =\u003e {\n  const [value, setValue] = React.useState(\n    localStorage.getItem(key) || initialState\n  );\n\n  React.useEffect(() =\u003e {\n    localStorage.setItem(key, value);\n  }, [value]);  // 此处应该是笔误，书中是传递[value, key]\n\n  return [value, setValue];\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e1.20 React Fragments\u003c/h2\u003e\n\u003cp\u003ecomponent返回时如果不想要\u003ccode\u003e\u0026#x3C;div\u003e\u003c/code\u003e包着，需要定义每个元素的key，react支持\u003ccode\u003e\u0026#x3C;\u003e\u003c/code\u003e即所谓fragment，来表示top-level element，但是不会有rendered output。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003econst Search = ({search, onSearch}) = (\n  \u0026#x3C;\u003e\n    \u0026#x3C;label ... /\u003e\n    \u0026#x3C;input ... /\u003e\n  \u0026#x3C;/\u003e\n)\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e1.21 Resuable React Component\u003c/h2\u003e\n\u003cp\u003e从search box抽象出\u003ccode\u003eInputWithLabel\u003c/code\u003e，结合js的\u003ccode\u003edefault parameter\u003c/code\u003e语法，能够让component容易复用。\u003c/p\u003e\n\u003ch2\u003e1.22 React Component Composition\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003echildren\u003c/code\u003e prop是react的一个特殊的prop，能够支持react component像html element那样嵌套组合：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003econst Input = ({id, children}) =\u003e (\n  \u0026#x3C;\u003e\n    \u0026#x3C;input id={id} ... /\u003e\n  \u0026#x3C;/\u003e\n)\n\nconst App = () =\u003e (\n  \u0026#x3C;div\u003e\n    \u0026#x3C;Input id=\"search\"\u003e\n      \u0026#x3C;strong\u003eSearch:\u0026#x3C;/strong\u003e\n    \u0026#x3C;/Input\u003e\n  \u0026#x3C;/div\u003e\n)\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e1.23 Imperative React\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003eimperative\u003c/code\u003e和\u003ccode\u003edeclarative\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003ereact也支持直接访问dom element，来做一些事：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003e\nconst Input = (isFocused=false) =\u003e {\n  const ref = React.useRef()\n\n  React.useEffect(() =\u003e {\n    if (isFocused \u0026#x26;\u0026#x26; ref.current) {\n      ref.current.focus();\n    };\n  }, [isFocused]);\n\n  return (\n    \u0026#x3C;\u003e\n      \u0026#x3C;input ref={ref}/\u003e\n    \u0026#x3C;/\u003e\n  )\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e1.24 Inline Handler in JSX\u003c/h2\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003econst Item = ({item, onRemoveItem}) =\u003e (\n  \u0026#x3C;\u003e\n    \u0026#x3C;button onClick={() =\u003e onRemoveItem(item)}\u003e\n  \u0026#x3C;/\u003e\n)\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e1.25 React Asynchronous Data\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003ePromise\u003c/code\u003e的使用：\u003ccode\u003e.then\u003c/code\u003e, \u003ccode\u003e.catch\u003c/code\u003e\u003c/p\u003e\n\u003ch2\u003e1.26 React Conditional Rendering\u003c/h2\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003e{isLoading ? (\u0026#x3C;p\u003eLoading...\u0026#x3C;/p\u003e):()}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e1.27 React Advanced State\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003eReact.useReducer\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e类似发布事件：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e定义reducer，根据current state,type,action计算下一个状态\u003c/li\u003e\n\u003cli\u003edispatchFunc: 发布action\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2\u003e1.28 React Impossible States\u003c/h2\u003e\n\u003cp\u003e使用useReducer hook封装多个相关的状态，减少\u003ccode\u003eimpossible states\u003c/code\u003e发生的概率。\u003ccode\u003eimpossible state\u003c/code\u003e发生表示bug，或者带来错误的用户体验。\u003c/p\u003e\n\u003ch2\u003e1.29 Data Fetching with React\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003efetch\u003c/code\u003e api: \u003ccode\u003efetch(url).then(resp =\u003e resp.json()).then...\u003c/code\u003e\u003c/p\u003e\n\u003ch2\u003e1.30 Data Re-Fetching in React\u003c/h2\u003e\n\u003cp\u003euseEffect绑定一个state，当state变化时会执行对应逻辑，更新或者发布action\u003c/p\u003e\n\u003ch2\u003e1.31 Memorized Handler in React (Advanced)\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003eReact.useCallback\u003c/code\u003e: 状态发生变化时，直接调用该callback\u003c/p\u003e\n\u003cp\u003e死循环？没太看懂\u003c/p\u003e\n\u003ch2\u003e1.32 Explicit Data Fetching with React\u003c/h2\u003e\n\u003cp\u003e使用\"按钮按下\"的side effect来发api请求，而不是每次input change。\u003c/p\u003e\n\u003cp\u003e想清楚ui是如何交互的，何时发生什么事件，然后再设计state。\u003c/p\u003e\n\u003ch2\u003e1.33 Third-Party Libraries in React\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003efetch\u003c/code\u003e是浏览器的api，\u003ccode\u003eaxios\u003c/code\u003e是一个library，用来发异步的请求。\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003enpm install axios\n\nimport axios from 'axios'\n\naxios.get(url).then(...)\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e1.34 Async/Await in React(Advanced)\u003c/h2\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003easync () =\u003e {\n  const result = await axios.get(url)  // wait\n}\n\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e1.35 Forms in React\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003eevent.preventDefault()\u003c/code\u003e: prevent browser reload\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eonSubmit\u003c/code\u003ehandler: react中处理表单提交的事件\u003c/p\u003e\n\u003ch2\u003e总结\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003e熟悉JSX语法\u003c/li\u003e\n\u003cli\u003e熟悉javascript的一些语法，例如arrow function, destructuring, promise, async/await\u003c/li\u003e\n\u003cli\u003e熟悉几个react hooks的用法\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch1\u003e参考\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003e不熟悉前端的必读:https://www.robinwieruch.de/javascript-fundamentals-react-requirements\u003c/li\u003e\n\u003c/ul\u003e\n"}},"__N_SSG":true},"page":"/blog/[link]","query":{"link":"2021-03-27 The road to react 笔记"},"buildId":"ravzvVxRlFE3_IAU4jdd7","nextExport":false,"isFallback":false,"gsp":true}</script><script nomodule="" src="/_next/static/chunks/polyfills-ff94e68042added27a93.js"></script><script src="/_next/static/chunks/main-c006ee6087559bbd65e3.js" async=""></script><script src="/_next/static/chunks/webpack-50bee04d1dc61f8adf5b.js" async=""></script><script src="/_next/static/chunks/framework.15878d4e523f86636251.js" async=""></script><script src="/_next/static/chunks/99f422a92ff7083adb8a7d840734144fa7589f68.e37cca09058b1656d546.js" async=""></script><script src="/_next/static/chunks/pages/_app-86af5e0fcdd51c9c3a66.js" async=""></script><script src="/_next/static/chunks/314642ff.81d3755a1df95fed9f2f.js" async=""></script><script src="/_next/static/chunks/762e22088df2ca7ea97d3f731b2a7315c482f91e.cb9acb13aef2b3683e00.js" async=""></script><script src="/_next/static/chunks/pages/blog/%5Blink%5D-87cd50cf458654f0c030.js" async=""></script><script src="/_next/static/ravzvVxRlFE3_IAU4jdd7/_buildManifest.js" async=""></script><script src="/_next/static/ravzvVxRlFE3_IAU4jdd7/_ssgManifest.js" async=""></script></body></html>