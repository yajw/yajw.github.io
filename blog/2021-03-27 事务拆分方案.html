<!DOCTYPE html><html><head><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><title>blog -  事务拆分方案</title><link rel="icon" href="/favicon.ico"/><link rel="stylesheet" href="/static/css/androidstudio.min.css"/><script src="/static/js/highlight.min.js"></script><script>hljs.highlightAll();</script><meta name="next-head-count" content="7"/><link rel="preload" href="/_next/static/css/3c5946e20da2cc20d075.css" as="style"/><link rel="stylesheet" href="/_next/static/css/3c5946e20da2cc20d075.css" data-n-g=""/><link rel="preload" href="/_next/static/css/e2e6dc732d39303ab748.css" as="style"/><link rel="stylesheet" href="/_next/static/css/e2e6dc732d39303ab748.css" data-n-p=""/><link rel="preload" href="/_next/static/css/4b5ef9ffeb729d4f1c31.css" as="style"/><link rel="stylesheet" href="/_next/static/css/4b5ef9ffeb729d4f1c31.css" data-n-p=""/><noscript data-n-css=""></noscript><link rel="preload" href="/_next/static/chunks/main-c006ee6087559bbd65e3.js" as="script"/><link rel="preload" href="/_next/static/chunks/webpack-50bee04d1dc61f8adf5b.js" as="script"/><link rel="preload" href="/_next/static/chunks/framework.15878d4e523f86636251.js" as="script"/><link rel="preload" href="/_next/static/chunks/99f422a92ff7083adb8a7d840734144fa7589f68.e37cca09058b1656d546.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/_app-86af5e0fcdd51c9c3a66.js" as="script"/><link rel="preload" href="/_next/static/chunks/314642ff.81d3755a1df95fed9f2f.js" as="script"/><link rel="preload" href="/_next/static/chunks/762e22088df2ca7ea97d3f731b2a7315c482f91e.cb9acb13aef2b3683e00.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/blog/%5Blink%5D-87cd50cf458654f0c030.js" as="script"/></head><body><div id="__next"><div class="Home_container__1EcsU"><main class="Home_main__1x8gC"><div class="ui text container"><h1 class="ui header"> 事务拆分方案</h1><span></span><section><p>先复习下分布式事务比较流行的几种方案。</p>
<p>考虑两个操作A和B，不放在一个事务内，怎么保证原子性（要么同时发生，要么同时不做/回滚）</p>
<h2>方案一：可靠消息</h2>
<p>通过消息队列，操作A执行成功，同时发送对应事件，操作B通过消费该事件来进行，即收到该事件，执行对应动作。</p>
<p>首先，MQ必须保证不丢消息。</p>
<p>RocketMQ的可靠消息实现：发送prepare消息 => 执行本地事务 => 发送ack消息，MQ定期询问没有ack的消息状态，所以需要实现一个回查事务是否成功的接口。</p>
<p>本地消息表的实现是：本地事务中，加入写本地消息表。事务执行成功，消息表自然也有一条对应记录，需要有一个调度任务，去发送消息，并且仅当发送明确成功时，才标记消息。</p>
<p>消费者消费消息，执行B操作。</p>
<p>如果消费者消费失败，一种是消费者实现幂等，可以重复消费，直到成功。</p>
<p>如果消费者不幂等，即只能消费一次，可以考虑消费者的ack和回查接口（RocketMQ实现）。</p>
<p>如果是不可重试的失败，需要业务上给出补偿方案，例如通知A操作执行者执行相应补偿。</p>
<h2>方案二：tcc</h2>
<p>tcc更多的是业务上的设计来保证最终一致性，不依赖数据库层面的事务或者某个特殊能力的组件。</p>
<p>将一个业务操作划分为try、commit/cancel三个动作。commit和cancel只会发生一个，即try阶段执行后，就能决定是cancel或者commit。</p>
<p>cancel和commit需要幂等，并且失败作补偿，或者走异常预案去处理。</p>
<h2>场景一：调第三方接口+更新本地</h2>
<p>举个例子，退款请求，第三方提供退款接口和查询接口，查询接口有一定同步延时，即可能出现退款接口返回成功后，一段时间内查询接口没有查到。</p>
<p>一种简单方案：</p>
<ol>
<li>本地标记prepare</li>
<li>调用退款 => 根据结果执行本地事务，更新某些字段，同时更新prepare为acked</li>
<li>定期轮询处于prepare阶段的本地事务，调用第三方的查询接口，根据结果来作相应处理（包括标记prepare）。如果第三方没结果，可能是由于第三方的同步延迟，需要重试查询，直到有明确的结论（确实没有调用退款，或者调用了退款）。</li>
</ol>
<p>定期轮询时，需要有一定的时间差，比如5分钟前prepare的。</p>
<h2>场景二：水平分库后跨db事务</h2>
<p>举个例子，将一个db库拆分成两个，两个库中的表都一样。PM提了个需求，要实现一个批量原子操作，有可能会同时操作这两个库。</p>
<p>方案一：
改造业务，避免出现跨库的操作。缺点可能是，业务改造成本大，有可能时间来不及。</p>
<p>方案二：
嵌套事务：两个库的操作外层嵌套两个库的事务（例如@Transactional或者python的atomic(db)）。</p>
<p>这么做的原因是，两个事务的顺序是：开启库1事务 => 开启库2事务 => 执行跨库操作 => 提交库2事务 => 提交库1事务
回滚是：开启库1事务 => 开启库2事务 => 执行跨库操作 => 回滚库2事务 => 回滚库1事务</p>
<p>即只要两个库的提交操作和回滚操作之间没有出现异常，就能保证跨库的原子性。</p>
<p>如果两个库的提交操作和回滚操作之间出现问题（例如进程被强制杀掉/断电/数据库挂掉/超时等），就会出现不一致。</p>
<h2>总结</h2>
<ol>
<li>业务上和产品设计，要有完善和明确的异常流程来兜底各种异常，出现问题可以走预案，而不是让研发或者运维去救火。</li>
<li>日志和监控能够cover住各种分支，出了问题，能快速定位。</li>
<li>最终一致性，并不仅仅是技术层面，需要结合业务层面去定义，甚至是业务层面用流程去cover住，避免技术去思考分布式事务的问题。</li>
</ol>
</section><div role="list" class="ui list"><div role="listitem" class="item">2021-03-27 14:49:15 +0800<!-- --> <!-- -->yajw<!-- --> <!-- -->Copy old posts<!-- --> <!-- -->A</div></div><div id="comments"></div></div></main><footer class="Home_footer__1WdhD"><div class="Home_powered__2GdUA">Powered by<!-- --> <a href="https://nextjs.org/" target="_blank" rel="noopener noreferrer">Next.js</a>.</div></footer></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":" 事务拆分方案","comments":true,"date":"2019-12-26T00:00:00.000Z","tags":["一致性","分布式事务"],"categories":["CAP"],"modifyTime":"2021-03-27 14:49:15 +0800","createTime":"2021-03-27 14:49:15 +0800","logs":[{"status":["A"],"files":["\"2021-03-27 \\344\\272\\213\\345\\212\\241\\346\\213\\206\\345\\210\\206\\346\\226\\271\\346\\241\\210.md\""],"abbrevHash":"f4f4061","hash":"f4f406175bde5279c552d8bac1c05cf7bb72d58e","subject":"Copy old posts","authorName":"yajw","authorDate":"2021-03-27 14:49:15 +0800"}],"link":"2021-03-27%20%E4%BA%8B%E5%8A%A1%E6%8B%86%E5%88%86%E6%96%B9%E6%A1%88","id":"4b064812-fbd5-4265-bb0a-1b402e307bdd","content":"\u003cp\u003e先复习下分布式事务比较流行的几种方案。\u003c/p\u003e\n\u003cp\u003e考虑两个操作A和B，不放在一个事务内，怎么保证原子性（要么同时发生，要么同时不做/回滚）\u003c/p\u003e\n\u003ch2\u003e方案一：可靠消息\u003c/h2\u003e\n\u003cp\u003e通过消息队列，操作A执行成功，同时发送对应事件，操作B通过消费该事件来进行，即收到该事件，执行对应动作。\u003c/p\u003e\n\u003cp\u003e首先，MQ必须保证不丢消息。\u003c/p\u003e\n\u003cp\u003eRocketMQ的可靠消息实现：发送prepare消息 =\u003e 执行本地事务 =\u003e 发送ack消息，MQ定期询问没有ack的消息状态，所以需要实现一个回查事务是否成功的接口。\u003c/p\u003e\n\u003cp\u003e本地消息表的实现是：本地事务中，加入写本地消息表。事务执行成功，消息表自然也有一条对应记录，需要有一个调度任务，去发送消息，并且仅当发送明确成功时，才标记消息。\u003c/p\u003e\n\u003cp\u003e消费者消费消息，执行B操作。\u003c/p\u003e\n\u003cp\u003e如果消费者消费失败，一种是消费者实现幂等，可以重复消费，直到成功。\u003c/p\u003e\n\u003cp\u003e如果消费者不幂等，即只能消费一次，可以考虑消费者的ack和回查接口（RocketMQ实现）。\u003c/p\u003e\n\u003cp\u003e如果是不可重试的失败，需要业务上给出补偿方案，例如通知A操作执行者执行相应补偿。\u003c/p\u003e\n\u003ch2\u003e方案二：tcc\u003c/h2\u003e\n\u003cp\u003etcc更多的是业务上的设计来保证最终一致性，不依赖数据库层面的事务或者某个特殊能力的组件。\u003c/p\u003e\n\u003cp\u003e将一个业务操作划分为try、commit/cancel三个动作。commit和cancel只会发生一个，即try阶段执行后，就能决定是cancel或者commit。\u003c/p\u003e\n\u003cp\u003ecancel和commit需要幂等，并且失败作补偿，或者走异常预案去处理。\u003c/p\u003e\n\u003ch2\u003e场景一：调第三方接口+更新本地\u003c/h2\u003e\n\u003cp\u003e举个例子，退款请求，第三方提供退款接口和查询接口，查询接口有一定同步延时，即可能出现退款接口返回成功后，一段时间内查询接口没有查到。\u003c/p\u003e\n\u003cp\u003e一种简单方案：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e本地标记prepare\u003c/li\u003e\n\u003cli\u003e调用退款 =\u003e 根据结果执行本地事务，更新某些字段，同时更新prepare为acked\u003c/li\u003e\n\u003cli\u003e定期轮询处于prepare阶段的本地事务，调用第三方的查询接口，根据结果来作相应处理（包括标记prepare）。如果第三方没结果，可能是由于第三方的同步延迟，需要重试查询，直到有明确的结论（确实没有调用退款，或者调用了退款）。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e定期轮询时，需要有一定的时间差，比如5分钟前prepare的。\u003c/p\u003e\n\u003ch2\u003e场景二：水平分库后跨db事务\u003c/h2\u003e\n\u003cp\u003e举个例子，将一个db库拆分成两个，两个库中的表都一样。PM提了个需求，要实现一个批量原子操作，有可能会同时操作这两个库。\u003c/p\u003e\n\u003cp\u003e方案一：\n改造业务，避免出现跨库的操作。缺点可能是，业务改造成本大，有可能时间来不及。\u003c/p\u003e\n\u003cp\u003e方案二：\n嵌套事务：两个库的操作外层嵌套两个库的事务（例如@Transactional或者python的atomic(db)）。\u003c/p\u003e\n\u003cp\u003e这么做的原因是，两个事务的顺序是：开启库1事务 =\u003e 开启库2事务 =\u003e 执行跨库操作 =\u003e 提交库2事务 =\u003e 提交库1事务\n回滚是：开启库1事务 =\u003e 开启库2事务 =\u003e 执行跨库操作 =\u003e 回滚库2事务 =\u003e 回滚库1事务\u003c/p\u003e\n\u003cp\u003e即只要两个库的提交操作和回滚操作之间没有出现异常，就能保证跨库的原子性。\u003c/p\u003e\n\u003cp\u003e如果两个库的提交操作和回滚操作之间出现问题（例如进程被强制杀掉/断电/数据库挂掉/超时等），就会出现不一致。\u003c/p\u003e\n\u003ch2\u003e总结\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003e业务上和产品设计，要有完善和明确的异常流程来兜底各种异常，出现问题可以走预案，而不是让研发或者运维去救火。\u003c/li\u003e\n\u003cli\u003e日志和监控能够cover住各种分支，出了问题，能快速定位。\u003c/li\u003e\n\u003cli\u003e最终一致性，并不仅仅是技术层面，需要结合业务层面去定义，甚至是业务层面用流程去cover住，避免技术去思考分布式事务的问题。\u003c/li\u003e\n\u003c/ol\u003e\n"}},"__N_SSG":true},"page":"/blog/[link]","query":{"link":"2021-03-27 事务拆分方案"},"buildId":"ravzvVxRlFE3_IAU4jdd7","nextExport":false,"isFallback":false,"gsp":true}</script><script nomodule="" src="/_next/static/chunks/polyfills-ff94e68042added27a93.js"></script><script src="/_next/static/chunks/main-c006ee6087559bbd65e3.js" async=""></script><script src="/_next/static/chunks/webpack-50bee04d1dc61f8adf5b.js" async=""></script><script src="/_next/static/chunks/framework.15878d4e523f86636251.js" async=""></script><script src="/_next/static/chunks/99f422a92ff7083adb8a7d840734144fa7589f68.e37cca09058b1656d546.js" async=""></script><script src="/_next/static/chunks/pages/_app-86af5e0fcdd51c9c3a66.js" async=""></script><script src="/_next/static/chunks/314642ff.81d3755a1df95fed9f2f.js" async=""></script><script src="/_next/static/chunks/762e22088df2ca7ea97d3f731b2a7315c482f91e.cb9acb13aef2b3683e00.js" async=""></script><script src="/_next/static/chunks/pages/blog/%5Blink%5D-87cd50cf458654f0c030.js" async=""></script><script src="/_next/static/ravzvVxRlFE3_IAU4jdd7/_buildManifest.js" async=""></script><script src="/_next/static/ravzvVxRlFE3_IAU4jdd7/_ssgManifest.js" async=""></script></body></html>